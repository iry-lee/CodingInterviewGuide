#include <climits>
#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <queue>

using namespace std;

int main(void){
    // 处理输入
    int n, m;
    cin >> n >> m;
    cin.get(); 	// 别忘了吃掉这个回车
    vector<vector<int>> matrix (n, vector<int>(m));
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            cin >> matrix[i][j];
    // 求最大矩形
    // cout << "begin calculate height\n";
    int ans = 0;
    // 1.在每一层上做切割，得到每一层往上有多少个连续的 1
    vector<vector<int>> height (n, vector<int>(m+1));
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            if(i == 0) height[i][j] = matrix[i][j];
            else if(matrix[i][j] == 0) height[i][j] = 0;
            else height[i][j] = height[i-1][j] + 1;
        }
        height[i][m] = 0;
    }

    // 2.然后在每一层上判断得到的矩形的最大面积，这里用到了栈
    // 比如这一层上是 [3,4,2,4,1,2]，如何判断最大的面积，这里可以想到接雨水的题
    // 维护一个单调递增的栈，但是每次进来小的值，都要往前消除
    for(int i = 0; i < n; i++){
        stack<int> st;
        st.push(-1); // 先往栈里push一个-1进去作为栈的底，这是一个小trick
        for(int j = 0; j < m+1; j++){
            while(st.top() != -1 && height[i][j] <= height[i][st.top()]){
                int top = st.top();
                st.pop();
                int temp = height[i][top]* (j-1 - st.top());
                if(temp > ans) ans = temp;
            }
            st.push(j);
        }
    }
    cout << ans;
    return 0;
}

// 题目：
// 给定一个不含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。
// 题目的意思是说，分别返回某一位置i的左边和右边第一个比arr[i]小的数所在的位置

// 求解思路：
// 这个题，如果使用暴力解法，那么时间复杂度是O(n^3)
// 一开始没有思路，看了一下书上题解的第一部分，才想到通过在每一层上求该层上面的连续的1的个数

// 输入：
/*
5 6
1 1 1 1 0 1
0 1 1 0 1 1
1 0 1 1 1 1
1 1 1 1 1 1
1 1 1 0 1 1
 */
// 输入：
/*
10 47
1 0 1 1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 1
0 1 1 1 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 1 0 0 1 1 0 1 1 0 1 0 1 1 0
0 1 0 1 0 1 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 0 0 0 1 1 0 1 1 1 0 0 1 1 1 0 0 0 1
1 1 0 0 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 0 1 1 0 1 1 0 1 0 1 0 0 0 0 1 1 1 0 0 0 1 0 1 1 1 0 1 0
1 0 0 0 0 1 1 1 1 0 1 1 0 0 1 1 1 0 1 1 0 0 0 1 1 1 1 1 0 0 0 1 0 1 1 1 0 1 1 1 1 1 1 0 1 1 1
1 1 1 0 0 1 1 1 1 1 1 1 1 0 1 0 0 0 0 1 0 1 1 1 1 0 0 0 0 1 1 0 1 1 1 1 1 1 0 1 0 1 1 0 0 0 1
1 1 0 1 1 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 1 1 1 1 0 1 1 0 1 1 1 0 1 1 1 1 0 1 1 0 1 1 0 0
0 1 1 0 1 1 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 1 1 1 0 0 0 1 0 0 0 1 1 0 1 1 0 0 0 1 0 0 1 1 1 1 0
0 1 1 1 1 0 0 0 1 0 1 0 0 0 1 1 0 1 0 1 0 1 0 0 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 1 1 1 1 0 0 0 0
1 0 1 1 0 0 0 0 0 1 1 0 1 0 1 0 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1 1 0 0 0 0 1 1 0 1 0 0 1 1 1

正确答案为 12

7 5
0 0 1 0 0
0 0 1 0 0
0 0 1 1 0
1 1 1 1 0
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1

正确答案 16

7 85
1 0 1 1 1 1 0 1 0 0 0 0 0 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 1 0 0 0 1 1 0 0 1 1 0 1 1 0 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 0 0 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 0 1 1 0 1 0 0 0 0
1 0 1 0 1 0 1 1 0 0 0 1 0 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 0 0 1 0 0 1 0 0 0 1 0 0 1 1 1 1 0 0 1 0 1 1 1 0 1 0 0 1 0 1 0 1 1 0 0 1 1 0 0 0 0 1 1 1 0 1 1 1 1 1 0 0 0 1 0 0
1 0 0 1 0 0 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 0 0 0 1 1 1 0 1 1 0 1 0 1 1 1 1 0 0 1 1 1 1 1 1 1 0 0 1 0 0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 1 1 0 0 1 1 1 1 0 0 1 1 0 0 0 1 1 0 0
0 1 1 1 1 0 1 1 0 1 1 1 1 1 1 1 1 0 1 1 0 1 1 0 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 0 1 0 0 1 1 0 1 0 1 1 1 0 0 1 1 0 0 1 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 1 1 1 0 1
1 0 1 0 1 1 0 1 1 1 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 1 1 0 0 1 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0 1 0 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 1 0 1 0 1 0 0 1 1
0 1 1 1 1 1 0 0 1 0 0 1 0 1 1 1 1 0 1 1 1 0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 1 0 1 0 1 1 0 1 1 0 0 0 1 1 1 0 1 0 1 0 1 1 1 0 0 0 0 1 0 1 0 1 0 0 0 1 1 1 1 1 0 0 1 1 0 1 1 0
0 1 1 1 0 1 0 0 1 1 1 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 1 1 0 0 0 1 0 0 0 0 0 1 1 1 1 0 1 1 1 0 0 0 1 0 1 0 1 1 0 0 1 1 1 0 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1

正确答案为 9
 */

// 出错的原因，有可能栈中有了（对应的是arr的值：[1,3,5]）再进来一个7，因为这里来的比较大，所以没有计算它
// 然后再进来一个0，直接给全消掉了，之前的面积都没有被算进来