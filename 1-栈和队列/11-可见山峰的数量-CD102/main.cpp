#include <climits>
#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <queue>

using namespace std;

int main(void){
    // 处理输入
    int T;
    cin >> T;
    cin.get(); 	// 别忘了吃掉这个回车
    // n, p, m 山峰数量，1-p的全排列，1-p的p!个全排列，取字典序的第m个的前n个数字
    vector<vector<int>> input (T, vector<int>(3));
    for(int i = 0; i < T; i++){
        cin >> input[i][0] >> input[i][1] >> input[i][2];
        cin.get();
    }

    // 可见山峰的数量，n组输入
    for(int i = 0; i < T; i++){
        int ans = 0;
        // 怎么得到全排列的字典序第m个？干掉最后一个顺序对，直到没有顺序对了
        // 比如：
        // [1] 1 2 3 4 5 6
        // [2] 1 2 3 4 6 5
        // [3] 1 2 3 6 4 5
        // [4] 1 2 3 6 5 4
        // [5] 1 2 6 3 5 4
        // 但是这样模拟的话时间复杂度太高了，模拟需要阶乘的复杂度
        // 可以根据m是p!的某一个阶段，先把后几个数字全部逆序了，
        // 然后是不是可以递归求解
        cout << ans;
    }


    return 0;
}

/*
题目描述：
一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。比如，{3,1,2,4,5}，{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山。3->1->2->4->5->3 方向叫作 next 方向(逆时针)，3->5->4->2->1->3 方向叫作 last 方向(顺时针)。
山峰 A 和 山峰 B 能够相互看见的条件为:
1. 如果 A 和 B 是同一座山，认为不能相互看见。
2. 如果 A 和 B 是不同的山，并且在环中相邻，认为可以相互看见。
3. 如果 A 和 B 是不同的山，并且在环中不相邻，假设两座山高度的最小值为 min。如果 A 通过 next 方向到 B 的途中没有高度比 min 大的山峰，或者 A 通过 last 方向到 B 的途中没有高度比 min 大的山峰，认为 A 和 B 可以相互看见。
问题如下：
给定一个不含有负数且没有重复值的数组 arr，请问有多少对山峰能够相互看见？

输入数据：
第一行一个整数 T，表示测试数据的组数。
每组数据的第一行有三个数字 n, p, m，其中 n 表示 山峰的数量，
山峰的高度数组等于 1 - p 的 p! 个全排列按字典序排序后的第 m 个全排列的前 n 项。
 */